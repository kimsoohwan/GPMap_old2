#ifndef ISO_SURFACE_EXTRACTION_HPP
#define ISO_SURFACE_EXTRACTION_HPP

// STL
#include <map>
#include <utility>
#include <cmath>			// floor
#include <algorithm>    // std::min_element, std::max_element

// PCL
#include <pcl/point_types.h>		// pcl::PointXYZ, pcl::Normal, pcl::PointNormal
#include <pcl/point_cloud.h>		// pcl::PointCloud

// GP
#include "GP.h"						// Epsilon
using GP::Epsilon;

// GPMap
#include "util/color_map.hpp"		// ColorMap

//#define AVOID_VERTEX_DUPLICATION

namespace GPMap {

//These tables are used so that everything can be done in little loops that you can look at all at once
// rather than in pages and pages of unrolled code.

//a2iVertexOffset lists the positions, relative to vertex0, of each of the 8 vertices of a cube
const int a2iVertexOffset[8][3] =
{
		{0, 0, 0},{1, 0, 0},{1, 1, 0},{0, 1, 0},
		{0, 0, 1},{1, 0, 1},{1, 1, 1},{0, 1, 1}
};

//a2fVertexOffset lists the positions, relative to vertex0, of each of the 8 vertices of a cube
const float a2fVertexOffset[8][3] =
{
		{0.0, 0.0, 0.0},{1.0, 0.0, 0.0},{1.0, 1.0, 0.0},{0.0, 1.0, 0.0},
		{0.0, 0.0, 1.0},{1.0, 0.0, 1.0},{1.0, 1.0, 1.0},{0.0, 1.0, 1.0}
};

//a2iEdgeConnection lists the index of the endpoint vertices for each of the 12 edges of the cube
const int a2iEdgeConnection[12][2] = 
{
		{0,1}, {1,2}, {2,3}, {3,0},
		{4,5}, {5,6}, {6,7}, {7,4},
		{0,4}, {1,5}, {2,6}, {3,7}
};

//a2fEdgeDirection lists the direction vector (vertex1-vertex0) for each edge in the cube
const float a2fEdgeDirection[12][3] =
{
		{1.0, 0.0, 0.0},{0.0, 1.0, 0.0},{-1.0, 0.0, 0.0},{0.0, -1.0, 0.0},
		{1.0, 0.0, 0.0},{0.0, 1.0, 0.0},{-1.0, 0.0, 0.0},{0.0, -1.0, 0.0},
		{0.0, 0.0, 1.0},{0.0, 0.0, 1.0},{ 0.0, 0.0, 1.0},{0.0,  0.0, 1.0}
};

// For any edge, if one vertex is inside of the surface and the other is outside of the surface
//  then the edge intersects the surface
// For each of the 8 vertices of the cube can be two possible states : either inside or outside of the surface
// For any cube the are 2^8=256 possible sets of vertex states
// This table lists the edges intersected by the surface for all 256 possible vertex states
// There are 12 edges.  For each entry in the table, if edge #n is intersected, then bit #n is set to 1

const int aiCubeEdgeFlags[256]=
{
		0x000, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 
		0x190, 0x099, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 
		0x230, 0x339, 0x033, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 
		0x3a0, 0x2a9, 0x1a3, 0x0aa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 
		0x460, 0x569, 0x663, 0x76a, 0x066, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 
		0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0x0ff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 
		0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x055, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 
		0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0x0cc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 
		0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x0cc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 
		0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x055, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 
		0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0x0ff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 
		0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x066, 0x76a, 0x663, 0x569, 0x460, 
		0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0x0aa, 0x1a3, 0x2a9, 0x3a0, 
		0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x033, 0x339, 0x230, 
		0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x099, 0x190, 
		0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x000
};

//  For each of the possible vertex states listed in aiCubeEdgeFlags there is a specific triangulation
//  of the edge intersection points.  a2iTriangleConnectionTable lists all of them in the form of
//  0-5 edge triples with the list terminated by the invalid value -1.
//  For example: a2iTriangleConnectionTable[3] list the 2 triangles formed when corner[0] 
//  and corner[1] are inside of the surface, but the rest of the cube is not.
//
//  I found this table in an example program someone wrote long ago.  It was probably generated by hand

const int a2iTriangleConnectionTable[256][16] =  
{
		{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},
		{3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},
		{3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},
		{3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},
		{9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},
		{1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},
		{9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
		{2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},
		{8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},
		{9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
		{4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},
		{3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},
		{1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},
		{4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},
		{4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},
		{9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
		{1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
		{5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},
		{2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},
		{9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
		{0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
		{2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
		{10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
		{4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},
		{5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
		{5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
		{9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
		{0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},
		{1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
		{10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},
		{8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
		{2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},
		{7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
		{9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
		{2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
		{11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
		{9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},
		{5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
		{11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
		{11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
		{1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
		{9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},
		{5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
		{2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
		{0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
		{5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},
		{6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},
		{0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
		{3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},
		{6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
		{5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
		{1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
		{10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
		{6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
		{1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},
		{8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
		{7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
		{3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
		{5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
		{0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},
		{9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
		{8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},
		{5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
		{0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
		{6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},
		{10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
		{10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
		{8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
		{1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},
		{3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
		{0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
		{10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
		{0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},
		{3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
		{6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
		{9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
		{8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
		{3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},
		{6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
		{0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
		{10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
		{10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},
		{1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
		{2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
		{7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
		{7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},
		{2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
		{1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
		{11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
		{8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
		{0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
		{7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
		{10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
		{2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
		{6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},
		{7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
		{2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
		{1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
		{10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},
		{10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
		{0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
		{7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
		{6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},
		{8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
		{9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
		{6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
		{1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
		{4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},
		{10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
		{8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
		{0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
		{1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},
		{8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
		{10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
		{4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
		{10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
		{5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
		{11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
		{9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
		{6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},
		{7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},
		{3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
		{7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},
		{9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
		{3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},
		{6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
		{9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
		{1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
		{4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
		{7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},
		{6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
		{3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
		{0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
		{6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
		{1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},
		{0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
		{11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
		{6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
		{5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
		{9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},
		{1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
		{1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
		{10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
		{0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
		{5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
		{10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},
		{11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
		{0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
		{9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
		{7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
		{2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},
		{8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
		{9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
		{9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
		{1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},
		{9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
		{9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
		{5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
		{0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},
		{10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
		{2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
		{0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
		{0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
		{9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},
		{5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
		{3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
		{5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
		{8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},
		{0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
		{9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
		{0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},
		{1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
		{3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
		{4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
		{9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
		{11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},
		{11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
		{2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
		{9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
		{3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
		{1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},
		{4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
		{4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
		{0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
		{3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
		{3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},
		{0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
		{9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},
		{1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
		{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

//a2iTetrahedronEdgeConnection lists the index of the endpoint vertices for each of the 6 edges of the tetrahedron
const int a2iTetrahedronEdgeConnection[6][2] =
{
		{0,1},  {1,2},  {2,0},  {0,3},  {1,3},  {2,3}
};

//a2iTetrahedronEdgeConnection lists the index of verticies from a cube 
// that made up each of the six tetrahedrons within the cube
const int a2iTetrahedronsInACube[6][4] =
{
		{0,5,1,6},
		{0,1,2,6},
		{0,2,3,6},
		{0,3,7,6},
		{0,7,4,6},
		{0,4,5,6},
};

// For any edge, if one vertex is inside of the surface and the other is outside of the surface
//  then the edge intersects the surface
// For each of the 4 vertices of the tetrahedron can be two possible states : either inside or outside of the surface
// For any tetrahedron the are 2^4=16 possible sets of vertex states
// This table lists the edges intersected by the surface for all 16 possible vertex states
// There are 6 edges.  For each entry in the table, if edge #n is intersected, then bit #n is set to 1

const int aiTetrahedronEdgeFlags[16]=
{
		0x00, 0x0d, 0x13, 0x1e, 0x26, 0x2b, 0x35, 0x38, 0x38, 0x35, 0x2b, 0x26, 0x1e, 0x13, 0x0d, 0x00, 
};


// For each of the possible vertex states listed in aiTetrahedronEdgeFlags there is a specific triangulation
// of the edge intersection points.  a2iTetrahedronTriangles lists all of them in the form of
// 0-2 edge triples with the list terminated by the invalid value -1.
//
// I generated this table by hand

const int a2iTetrahedronTriangles[16][7] =
{
		{-1, -1, -1, -1, -1, -1, -1},
		{ 0,  3,  2, -1, -1, -1, -1},
		{ 0,  1,  4, -1, -1, -1, -1},
		{ 1,  4,  2,  2,  4,  3, -1},

		{ 1,  2,  5, -1, -1, -1, -1},
		{ 0,  3,  5,  0,  5,  1, -1},
		{ 0,  2,  5,  0,  5,  4, -1},
		{ 5,  4,  3, -1, -1, -1, -1},

		{ 3,  4,  5, -1, -1, -1, -1},
		{ 4,  5,  0,  5,  2,  0, -1},
		{ 1,  5,  0,  5,  3,  0, -1},
		{ 5,  2,  1, -1, -1, -1, -1},

		{ 3,  4,  2,  2,  4,  1, -1},
		{ 4,  1,  0, -1, -1, -1, -1},
		{ 2,  3,  0, -1, -1, -1, -1},
		{-1, -1, -1, -1, -1, -1, -1},
};

/** @class Three dimensional vector or point */
template <typename T>
class Vector3D
{
public:
	union
	{
		struct {T x, y, z;};
		T val[3];
	};

	Vector3D()
	{
	}

	Vector3D(const T _x, const T _y, const T _z)
		: x(_x), y(_y), z(_z)
	{
	}

	Vector3D(const Vector3D& other)
		: x(other.x), y(other.y), z(other.z)
	{
	}

	Vector3D& operator=(const Vector3D &other)
	{
		this->x = other.x;
		this->y = other.y;
		this->z = other.z;
		return *this;
	}

	//bool operator==(const Vector3D &other) const
	//{
	//	// exact comparison
	//	if(this->x != other.x) return false;
	//	if(this->y != other.y) return false;
	//	if(this->z != other.z) return false;

	//	// approx comparison
	//	//if(!equal(this->x, other.x)) return false;
	//	//if(!equal(this->y, other.y)) return false;
	//	//if(!equal(this->z, other.z)) return false;
	//	return true;
	//}

	//bool operator!=(const Vector3D &rhs) const
	//{
	//	return !((*this) == rhs);
	//}

	/** @brief Comparison operator for insert and find in the STL map */
	bool operator<(const Vector3D &other) const
	{
		// priority: x, y, z
		//if(this->x == other.x)
		//{
		//	if(this->y == other.y)
		//	{
		//		return this->z < other.z;
		//	}
		//	return this->y < other.y;
		//}
		//return this->x < other.x;

		// priority: x, y, z
		if (x != other.x)	return (x < other.x);
		if (y != other.y)	return (y < other.y);
		return (z < other.z);
	}


	friend std::ostream& operator<<(std::ostream &output, const Vector3D &v)
	{
		output << v.x << " " << v.y << " " << v.z;
		return output;
	}

};
typedef Vector3D<int> Key3D;

/** @class Compare operator for three dimensional vector or point */
template <typename T>
struct CompareVector3D
{
	inline bool operator() (const Vector3D<T> &lhs, const Vector3D<T> &rhs)
	{
		// priority: x, y, z
		if(equal(lhs.x, rhs.x))
		{
			if(equal(lhs.y, rhs.y))
			{
				return !equal(lhs.z, rhs.z) && (lhs.z < rhs.z);
			}
			return lhs.y < rhs.y;
		}
		return lhs.x < rhs.x;
	}

	inline bool equal(const T value1, const T value2) const
	{
		return abs(value1 - value2) < Epsilon<T>::value;
	}
};

/** @class 1D Gaussian distribution with a mean and a variance */
template <typename T>
struct GaussianDistribution1D
{
	GaussianDistribution1D(const T mu, const T sigma)
		: mean(mu), var(sigma)
	{
	}
	
	GaussianDistribution1D& operator=(const GaussianDistribution1D &other)
	{
		mean	= other.mean;
		var	= other.var;
		return *this;
	}

	T mean;
	T var;
};
typedef GaussianDistribution1D<float> GaussianDistribution1Df;

/** @class IsoSurfaceExtraction */
class IsoSurfaceExtraction
{
public:
	typedef enum ColorMode_ {
		COLOR_BY_X,	// x
		COLOR_BY_Y,	// y
		COLOR_BY_Z,	// z
		COLOR_BY_V	// variance
	} ColorMode;

public:
	/** @brief	Constructor with a resolution*/
	IsoSurfaceExtraction(const float resolution)
		: m_resolution(resolution)
	{
	}
	
	/** @brief	Convert a GPMap to an Octree or a ColorOctree based on PLSC */
	size_t insertMeanVarFromGPMap(const pcl::PointCloud<pcl::PointNormal>	&pointCloud)
	{
		// for each point
		for(size_t i = 0; i < pointCloud.points.size(); i++)
		{
			// point
			const pcl::PointNormal &point = pointCloud.points[i];

			// insert
			insertMeanVar(point.x, point.y, point.z, point.normal_x, point.normal_y);
		}

		// min, max of mean values
		float minMean	= std::numeric_limits<float>::max();
		float maxMean	= std::numeric_limits<float>::min();
		float minVar	= std::numeric_limits<float>::max();
		float maxVar	= std::numeric_limits<float>::min();
	
		// for each scalar field
		for(std::map<Key3D, GaussianDistribution1Df>::const_iterator iter = m_gridScalarField.begin(); iter != m_gridScalarField.end(); iter++)
		{
			// min, max
			minMean	= std::min<float>(minMean,	iter->second.mean);
			maxMean	= std::max<float>(maxMean,	iter->second.mean);
			minVar	= std::min<float>(minVar,	iter->second.var);
			maxVar	= std::max<float>(maxVar,	iter->second.var);
		}

		// log file
		LogFile logFile;
		logFile << "insertMeanVarFromGPMap" << std::endl;
		logFile << "Min Mean: " << minMean << std::endl;
		logFile << "Max Mean: " << maxMean << std::endl;
		logFile << "Min Var: "  << minVar  << std::endl;
		logFile << "Max Var: "  << maxVar  << std::endl;

		// number of grid points
		return m_gridScalarField.size();
	}

	/** @brief	Add the inferred mean and variance of a signed distance at a 3D position to the scalar field */
	inline void insertMeanVar(const float x, const float y, const float z,
									  const float mean, const float var)
	{
		// key
		const int ix = static_cast<int>(x / m_resolution);
		const int iy = static_cast<int>(y / m_resolution);
		const int iz = static_cast<int>(z / m_resolution);
		//const int ix = floor(x / m_resolution);
		//const int iy = floor(y / m_resolution);
		//const int iz = floor(z / m_resolution);

		m_originX = x - static_cast<float>(ix) * m_resolution;
		m_originY = y - static_cast<float>(iy) * m_resolution;
		m_originZ = z - static_cast<float>(iz) * m_resolution;

		// insert mean and variance with key
		m_gridScalarField.insert(std::pair<Key3D, 
													  GaussianDistribution1Df>(Key3D(ix, iy, iz), 
																						GaussianDistribution1Df(mean, var)));
	}

	/** @brief	Get the size of the scalar field */
	inline size_t size() const
	{
		return m_gridScalarField.size();
	}

	/** @brief	Perform Marching Cubes */
	size_t marchingcubes(const float fTargetValue = 0.f)
	{
		// clear the results
		m_vertices.clear();
		m_triangles.clear();
		m_vertexValuesForColor_X.clear();
		m_vertexValuesForColor_Y.clear();
		m_vertexValuesForColor_Z.clear();
		m_vertexValuesForColor_V.clear();

		// for each grid point in the scalar field
		for(std::map<Key3D, GaussianDistribution1Df>::const_iterator currGridPointIter = m_gridScalarField.begin(); 
			 currGridPointIter != m_gridScalarField.end(); currGridPointIter++)
		{
			// current key
			Key3D currKey(currGridPointIter->first);

			//Make a local copy of the values at the cube's 8 corners
			bool bCubeExists = true;
			float afCubeMean[8];			// local copy of the cube mean values
			float afCubeVariance[8];	// local copy of the cube variance values
			for(unsigned int iVertex = 0; iVertex < 8; iVertex++)
			{
				// next key
				Key3D nextKey(currKey.x + a2iVertexOffset[iVertex][0],
								  currKey.y + a2iVertexOffset[iVertex][1],
								  currKey.z + a2iVertexOffset[iVertex][2]);

				// find the next point in the grid scalar field
				std::map<Key3D, GaussianDistribution1Df>::const_iterator nextGridPointIter = m_gridScalarField.find(nextKey);

				// if it is not in the scalar field
				if(nextGridPointIter == m_gridScalarField.end())
				{
					bCubeExists = false;
					break;

					//if(iVertex == 0)
					//{
					//	bCubeExists = false;
					//	break;
					//}

					//if(iVertex == 4)	afCubeMean[iVertex] = afCubeMean[0];			// first
					//else				afCubeMean[iVertex] = afCubeMean[iVertex-1];	// previous

					//afCubeMean[iVertex]		= 0.f;
					//afCubeVariance[iVertex] = 0.f;
				}
				else
				{
					afCubeMean[iVertex]		= nextGridPointIter->second.mean;
					afCubeVariance[iVertex]	= nextGridPointIter->second.var;
				}
			}

			// if all 8 neighbors do not exit, move to the next cube
			if(!bCubeExists) continue;
			//for(unsigned int iVertex = 0; iVertex < 8; iVertex++)
			//{
			//	std::cout << afCubeMean[iVertex] << ", ";
			//}
			//std::cout << std::endl;

			//Find which vertices are inside of the surface and which are outside
			int iFlagIndex = 0;
			for(unsigned int iVertex = 0; iVertex < 8; iVertex++)
			{
				if(afCubeMean[iVertex] <= fTargetValue) 
							iFlagIndex |= 1<<iVertex;
			}

			//Find which edges are intersected by the surface
			int iEdgeFlags = aiCubeEdgeFlags[iFlagIndex];

			//If the cube is entirely inside or outside of the surface, then there will be no intersections
			if(iEdgeFlags == 0) 
			{
					continue;
			}
			//std::cout << "Found a valid cube!" << std::endl;

			// real 3D point
			float x = m_originX + static_cast<float>(currKey.x) * m_resolution;
			float y = m_originY + static_cast<float>(currKey.y) * m_resolution;
			float z = m_originZ + static_cast<float>(currKey.z) * m_resolution;

			//Find the point of intersection of the surface with each edge
			//Then find the normal to the surface at those points
			Vector3D<float>	asEdgeVertex[12];	// intersection verticies on edges
			//Vector3D<float> asEdgeNorm[6];
			float  asEdgeVertexVariance[12];	// intersection verticies on edges
			for(unsigned int iEdge = 0; iEdge < 12; iEdge++)
			{
				//if there is an intersection on this edge
				if(iEdgeFlags & (1<<iEdge))
				{
					// offset
					float fOffset = fGetOffset(afCubeMean[ a2iEdgeConnection[iEdge][0] ], afCubeMean[ a2iEdgeConnection[iEdge][1] ], fTargetValue);

					// intersecting vertex
					asEdgeVertex[iEdge].x = x + (a2fVertexOffset[ a2iEdgeConnection[iEdge][0] ][0]  +  fOffset * a2fEdgeDirection[iEdge][0]) * m_resolution;
					asEdgeVertex[iEdge].y = y + (a2fVertexOffset[ a2iEdgeConnection[iEdge][0] ][1]  +  fOffset * a2fEdgeDirection[iEdge][1]) * m_resolution;
					asEdgeVertex[iEdge].z = z + (a2fVertexOffset[ a2iEdgeConnection[iEdge][0] ][2]  +  fOffset * a2fEdgeDirection[iEdge][2]) * m_resolution;

					// surface normal
					//vGetNormal(asEdgeNorm[iEdge], asEdgeVertex[iEdge].x, asEdgeVertex[iEdge].y, asEdgeVertex[iEdge].z);

					// vertex variance value
					asEdgeVertexVariance[iEdge] = fOffset*afCubeVariance[ a2iEdgeConnection[iEdge][1] ]
												+ (1.f - fOffset)*afCubeVariance[ a2iEdgeConnection[iEdge][0] ];
				}
			}

			//Draw the triangles that were found.  There can be up to five per cube
			for(unsigned int iTriangle = 0; iTriangle < 5; iTriangle++)
			{
				if(a2iTriangleConnectionTable[iFlagIndex][3*iTriangle] < 0)
						break;

				// draw a triangle
				Vector3D<unsigned int> triangle;
				for(unsigned int iiCorner = 0; iiCorner < 3; iiCorner++)
				{
					unsigned int iCorner;
					switch(iiCorner)
					{
					case 0: { iCorner = 0; break; }
					case 1: { iCorner = 2; break; }
					case 2: { iCorner = 1; break; }
					}

					int iVertex = a2iTriangleConnectionTable[iFlagIndex][3*iTriangle+iCorner];

#ifdef AVOID_VERTEX_DUPLICATION
					Vector3D<float> vertexPoint(asEdgeVertex[iVertex].x, asEdgeVertex[iVertex].y, asEdgeVertex[iVertex].z);
					std::map<Vector3D<float>, unsigned int, ComparePoint3D>::const_iterator vertexIter = m_vertices.find(vertexPoint);
					if(vertexIter == m_vertices.end())
					{
						triangle.val[iCorner] = m_vertices.size();
						m_vertices.insert(std::pair<Vector3D<float>, unsigned int>(asEdgeVertex[iVertex], m_vertices.size()));
					}
					else
					{
						triangle.val[iCorner] = vertexIter->second;
					}
#else
					// vertex index
					triangle.val[iCorner] = m_vertices.size();

					// add the vertex
					m_vertices.push_back(asEdgeVertex[iVertex]);
#endif

					// add the vertex values for color
					m_vertexValuesForColor_X.push_back(asEdgeVertex[iVertex].x);
					m_vertexValuesForColor_Y.push_back(asEdgeVertex[iVertex].y);
					m_vertexValuesForColor_Z.push_back(asEdgeVertex[iVertex].z);
					m_vertexValuesForColor_V.push_back(asEdgeVertexVariance[iVertex]);
				}

				// add the triangle patch
				m_triangles.push_back(triangle);
			}
		}

		// return the number of triangle patches
		return m_triangles.size();
	}

	size_t marchingTetrahedron(const float fTargetValue = 0.f)
	{
		// clear the results
		m_vertices.clear();
		m_triangles.clear();
		m_vertexValuesForColor_X.clear();
		m_vertexValuesForColor_Y.clear();
		m_vertexValuesForColor_Z.clear();
		m_vertexValuesForColor_V.clear();

		for(std::map<Key3D, GaussianDistribution1Df>::const_iterator currGridPointIter = m_gridScalarField.begin(); currGridPointIter != m_gridScalarField.end(); currGridPointIter++)
		{
			// key
			Key3D currKey(currGridPointIter->first);
			Key3D asCubePosition[8];

			//Make a local copy of the values at the cube's corners
			bool bCubeExists = true;
			float afCubeMean[8];			// local copy of the cube mean values
			float afCubeVariance[8];	// local copy of the cube variance values
			for(unsigned int iVertex = 0; iVertex < 8; iVertex++)
			{
				// next key
				Key3D nextKey(currKey.x + a2iVertexOffset[iVertex][0],
								  currKey.y + a2iVertexOffset[iVertex][1],
								  currKey.z + a2iVertexOffset[iVertex][2]);

				// find the next point in the grid scalar field
				std::map<Key3D, GaussianDistribution1Df>::const_iterator nextGridPointIter = m_gridScalarField.find(nextKey);
				if(nextGridPointIter == m_gridScalarField.end())
				{
					bCubeExists = false;
					break;
				}
				else
				{
					// next point
					asCubePosition[iVertex] = nextKey;

					// mean, var 
					afCubeMean[iVertex]		= nextGridPointIter->second.mean;
					afCubeVariance[iVertex]	= nextGridPointIter->second.var;
				}
			}

			// if all 8 neighbors do not exit, move to the next cube
			if(!bCubeExists) continue;

			// for each tetrahedron
			for(unsigned int iTetrahedron = 0; iTetrahedron < 6; iTetrahedron++)
			{
				Key3D	asTetrahedronPosition[4];
				float				afTetrahedronMean[4];	
				float				afTetrahedronVariance[4];	
				for(unsigned int iVertex = 0; iVertex < 4; iVertex++)
				{
						int iVertexInACube = a2iTetrahedronsInACube[iTetrahedron][iVertex];
						asTetrahedronPosition[iVertex].x = m_originX + static_cast<float>(asCubePosition[iVertexInACube].x) * m_resolution;
						asTetrahedronPosition[iVertex].y = m_originY + static_cast<float>(asCubePosition[iVertexInACube].y) * m_resolution;
						asTetrahedronPosition[iVertex].z = m_originZ + static_cast<float>(asCubePosition[iVertexInACube].z) * m_resolution;
						afTetrahedronMean[iVertex]			= afCubeMean[iVertexInACube];
						afTetrahedronVariance[iVertex]	= afCubeVariance[iVertexInACube];
				}
				vMarchTetrahedron(asTetrahedronPosition, afTetrahedronMean, afTetrahedronVariance, fTargetValue);
			}
		}

		return m_triangles.size();
	}

	//vMarchTetrahedron performs the Marching Tetrahedrons algorithm on a single tetrahedron
	void vMarchTetrahedron(Key3D (&pasTetrahedronPosition)[4], float (&pafTetrahedronMean)[4], float (&pafTetrahedronVariance)[4], const float fTargetValue)
	{
		int iEdge, iVert0, iVert1, iEdgeFlags, iTriangle, iCorner, iVertex, iFlagIndex = 0;
		float fOffset, fInvOffset, fValue = 0.0;
		Vector3D<float> asEdgeVertex[6];	// intersection verticies on edges
		//Vector3D<float> asEdgeNorm[6];
		float  asEdgeVertexVariance[6];	// intersection verticies on edges

		//Find which vertices are inside of the surface and which are outside
		for(iVertex = 0; iVertex < 4; iVertex++)
		{
				if(pafTetrahedronMean[iVertex] <= fTargetValue) 
						iFlagIndex |= 1<<iVertex;
		}

		//Find which edges are intersected by the surface
		iEdgeFlags = aiTetrahedronEdgeFlags[iFlagIndex];

		//If the tetrahedron is entirely inside or outside of the surface, then there will be no intersections
		if(iEdgeFlags == 0)
		{
				return;
		}
		//Find the point of intersection of the surface with each edge
		// Then find the normal to the surface at those points
		for(iEdge = 0; iEdge < 6; iEdge++)
		{
			//if there is an intersection on this edge
			if(iEdgeFlags & (1<<iEdge))
			{
				// offset
				iVert0 = a2iTetrahedronEdgeConnection[iEdge][0];
				iVert1 = a2iTetrahedronEdgeConnection[iEdge][1];
				fOffset = fGetOffset(pafTetrahedronMean[iVert0], pafTetrahedronMean[iVert1], fTargetValue);
				fInvOffset = 1.0 - fOffset;

				// intersecting vertex
				asEdgeVertex[iEdge].x = fInvOffset*pasTetrahedronPosition[iVert0].x  +  fOffset*pasTetrahedronPosition[iVert1].x;
				asEdgeVertex[iEdge].y = fInvOffset*pasTetrahedronPosition[iVert0].y  +  fOffset*pasTetrahedronPosition[iVert1].y;
				asEdgeVertex[iEdge].z = fInvOffset*pasTetrahedronPosition[iVert0].z  +  fOffset*pasTetrahedronPosition[iVert1].z;
            
				// surface normal
				//vGetNormal(asEdgeNorm[iEdge], asEdgeVertex[iEdge].x, asEdgeVertex[iEdge].y, asEdgeVertex[iEdge].z);

				// vertex variance value
				asEdgeVertexVariance[iEdge] = fInvOffset*pafTetrahedronVariance[iVert0] + fOffset*pafTetrahedronVariance[iVert1];
			}
		}

		//Draw the triangles that were found.  There can be up to 2 per tetrahedron
		for(iTriangle = 0; iTriangle < 2; iTriangle++)
		{
			if(a2iTetrahedronTriangles[iFlagIndex][3*iTriangle] < 0)
					break;

			Vector3D<unsigned int> triangle;
			for(iCorner = 0; iCorner < 3; iCorner++)
			{
				iVertex = a2iTetrahedronTriangles[iFlagIndex][3*iTriangle+iCorner];

				// vertex index
				triangle.val[iCorner] = m_vertices.size();

				// add the vertex
				m_vertices.push_back(asEdgeVertex[iVertex]);
			}

			// add the triangle patch
			m_triangles.push_back(triangle);
		}
	}

	/** @brief	Get the minimum vertex value for color */
	float getMinVertexValueForColor(const ColorMode colorMode) const
	{
		assert(m_vertexValuesForColor_X.size() > 0);
		switch(colorMode)
		{
		case COLOR_BY_X: return *std::min_element(m_vertexValuesForColor_X.begin(), m_vertexValuesForColor_X.end());
		case COLOR_BY_Y: return *std::min_element(m_vertexValuesForColor_Y.begin(), m_vertexValuesForColor_Y.end());
		case COLOR_BY_Z: return *std::min_element(m_vertexValuesForColor_Z.begin(), m_vertexValuesForColor_Z.end());
		case COLOR_BY_V: return *std::min_element(m_vertexValuesForColor_V.begin(), m_vertexValuesForColor_V.end());
		}
		return 0;
	}

	/** @brief	Get the maximum vertex value for color */
	float getMaxVertexValueForColor(const ColorMode colorMode) const
	{
		assert(m_vertexValuesForColor_X.size() > 0);
		switch(colorMode)
		{
		case COLOR_BY_X: return *std::max_element(m_vertexValuesForColor_X.begin(), m_vertexValuesForColor_X.end());
		case COLOR_BY_Y: return *std::max_element(m_vertexValuesForColor_Y.begin(), m_vertexValuesForColor_Y.end());
		case COLOR_BY_Z: return *std::max_element(m_vertexValuesForColor_Z.begin(), m_vertexValuesForColor_Z.end());
		case COLOR_BY_V: return *std::max_element(m_vertexValuesForColor_V.begin(), m_vertexValuesForColor_V.end());
		}
		return 0;
	}

	/** @brief	Set the colors of vertices */
	void setVertexColors(const ColorMode colorMode, float minValueForColor = 0.f, float maxValueForColor = 0.f)
	{
		// reset
		m_vertexRGBColors.clear();

		// default color
		if(minValueForColor == maxValueForColor)
		{
			minValueForColor = getMinVertexValueForColor(colorMode);
			maxValueForColor = getMaxVertexValueForColor(colorMode);
		}

		// color map
		ColorMap colorMap(minValueForColor, maxValueForColor);

		// RGB color
		Vector3D<unsigned char> RGB;

		// vertex value iterators
		std::vector<float>::const_iterator vertexValueIter;
		std::vector<float>::const_iterator vertexValueIterEnd;
		switch(colorMode)
		{
		case COLOR_BY_X: vertexValueIter = m_vertexValuesForColor_X.begin(); vertexValueIterEnd = m_vertexValuesForColor_X.end(); break;
		case COLOR_BY_Y: vertexValueIter = m_vertexValuesForColor_Y.begin(); vertexValueIterEnd = m_vertexValuesForColor_Y.end(); break;
		case COLOR_BY_Z: vertexValueIter = m_vertexValuesForColor_Z.begin(); vertexValueIterEnd = m_vertexValuesForColor_Z.end(); break;
		case COLOR_BY_V: vertexValueIter = m_vertexValuesForColor_V.begin(); vertexValueIterEnd = m_vertexValuesForColor_V.end(); break;
		}

		// for each color values
		for(; vertexValueIter != vertexValueIterEnd; vertexValueIter++)
		{
			// corresponding RGB
			colorMap.rgb(*vertexValueIter, RGB.x, RGB.y, RGB.z);

			// add to the list
			m_vertexRGBColors.push_back(RGB);
		}
	}

	/** @brief	Save as a ply file */
	void saveAsPLY(const std::string &strFilePath) const
	{
		//std::ofstream fout(strFilePath, std::ios::out | std::ios::binary);
		std::ofstream fout(strFilePath);
		fout << "ply" << std::endl;
		fout << "format ascii 1.0" << std::endl;
		//fout << "format binary_little_endian 1.0" << std::endl;
		fout << "comment made by marching cubes" << std::endl;
		fout << "element vertex " << m_vertices.size() << std::endl;
		fout << "property float x" << std::endl;
		fout << "property float y" << std::endl;
		fout << "property float z" << std::endl;
		if(m_vertexRGBColors.size() > 0)
		{
			fout << "property uchar red" << std::endl;
			fout << "property uchar green" << std::endl;
			fout << "property uchar blue" << std::endl;
		}
		fout << "element face " << m_triangles.size() << std::endl;
		//fout << "property list uchar vertex_indices" << std::endl;
		fout << "property list uchar int vertex_indices" << std::endl;
		fout << "end_header" << std::endl;

		// vertices
		if(m_vertexRGBColors.size() > 0)
		{
			for(size_t i = 0; i < m_vertices.size(); i++)
			{
				fout << m_vertices[i] << " " 
						<< static_cast<int>(m_vertexRGBColors[i].x) << " "
						<< static_cast<int>(m_vertexRGBColors[i].y) << " "
						<< static_cast<int>(m_vertexRGBColors[i].z) << std::endl;
			}
		}
		else
		{
			//std::map<Vector3D<float>, unsigned int>::const_iterator vertexIter;
			std::vector<Vector3D<float>>::const_iterator vertexIter;
			for(vertexIter = m_vertices.begin(); vertexIter != m_vertices.end(); vertexIter++)
			for(size_t i = 0; i < m_vertices.size(); i++)
			{
				//fout << vertexIter->first.x << " " << vertexIter->first.y << " " << vertexIter->first.z << std::endl;
				//fout << vertexIter->first;
				fout << *vertexIter << std::endl;
			}
		}


		// triangles
		std::vector<Vector3D<unsigned int> >::const_iterator triangleIter;
		for(triangleIter = m_triangles.begin(); triangleIter != m_triangles.end(); triangleIter++)
		{
			//fout << "3 " << triangleIter->x << " " << triangleIter->y << " " << triangleIter->z << std::endl;
			fout << "3 " << *triangleIter << std::endl;
		}
	}

protected:
	// fGetOffset finds the approximate point of intersection of the surface
	// between two points with the values fValue1 and fValue2
	inline float fGetOffset(const float fValue1, const float fValue2, const float fValueDesired) const
	{
		float fDelta = fValue2 - fValue1;
		return (fDelta == 0.0) ? 0.5 : (fValueDesired - fValue1)/fDelta;
	}

	// TODO: infer surface normal from Gaussian process regression
	//vGetNormal() finds the gradient of the scalar field at a point
	//This gradient can be used as a very accurate vertx normal for lighting calculations
	//inline void vGetNormal(GLvector &rfNormal, GLfloat fX, GLfloat fY, GLfloat fZ)
	//{
	//		  rfNormal.fX = fSample(fX-0.01, fY, fZ) - fSample(fX+0.01, fY, fZ);
	//		  rfNormal.fY = fSample(fX, fY-0.01, fZ) - fSample(fX, fY+0.01, fZ);
	//		  rfNormal.fZ = fSample(fX, fY, fZ-0.01) - fSample(fX, fY, fZ+0.01);
	//		  vNormalizeVector(rfNormal, rfNormal);
	//}

protected:

	/** @brief	Resolution of the grid */
	float m_resolution;

	/** @brief	Origin */
	float m_originX, m_originY, m_originZ;

	/** @brief		Scalar field of 1D Gaussian distribution with a mean and a variace in a grid space
	  * @details	Note that the 3D points are handled as integer grid point to make it easer finding neighbors */
	std::map<Key3D, GaussianDistribution1Df>					m_gridScalarField;

	/** @brief	Vertices */
#ifdef AVOID_VERTEX_DUPLICATION
	std::map<Vector3D<float>, unsigned int, ComparePoint3D>		m_vertices;
#else
	std::vector<Vector3D<float> >											m_vertices;
#endif

	/** @brief	Triangle patches */
	std::vector<Vector3D<unsigned int> >									m_triangles;

	/** @brief	Colors for vertices */
	std::vector<Vector3D<unsigned char> >								m_vertexRGBColors;

	/** @brief	vertex values for color */
	std::vector<float>														m_vertexValuesForColor_X;
	std::vector<float>														m_vertexValuesForColor_Y;
	std::vector<float>														m_vertexValuesForColor_Z;
	std::vector<float>														m_vertexValuesForColor_V;
};

/** @brief Get min and max of means and variances in GPMap */
static void getMinMaxMeanVar(const pcl::PointCloud<pcl::PointNormal>	&pointCloudGPMap,
									  float &minMean,	float &maxMean,
									  float &minVar,		float &maxVar)
{
	// min, max
	minMean	= std::numeric_limits<float>::max();
	maxMean	= std::numeric_limits<float>::min();
	minVar	= std::numeric_limits<float>::max();
	maxVar	= std::numeric_limits<float>::min();		

	// for each point
	for(size_t i = 0; i < pointCloudGPMap.points.size(); i++)
	{
		// point
		const pcl::PointNormal &point = pointCloudGPMap.points[i];

		// min, max
		minMean	= std::min<float>(minMean,		point.normal_x);
		maxMean	= std::max<float>(maxMean,		point.normal_x);
		minVar	= std::min<float>(minVar,		point.normal_y);
		maxVar	= std::max<float>(maxVar,		point.normal_y);
	}

	// log
	LogFile logFile;
	logFile << "getMinMaxMeanVar" << std::endl;
	logFile << "Min Mean: " << std::setprecision(std::numeric_limits<float>::digits10) << std::scientific << minMean << std::endl;
	logFile << "Max Mean: " << std::setprecision(std::numeric_limits<float>::digits10) << std::scientific << maxMean << std::endl;
	logFile << "Min Var: "  << std::setprecision(std::numeric_limits<float>::digits10) << std::scientific << minVar  << std::endl;
	logFile << "Max Var: "  << std::setprecision(std::numeric_limits<float>::digits10) << std::scientific << maxVar  << std::endl;
}

}

#endif
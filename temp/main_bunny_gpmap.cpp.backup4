#if 1
// Eigen
#include "serialization/eigen_serialization.hpp" // Eigen
// includes followings inside of it
//		- #define EIGEN_NO_DEBUG		// to speed up
//		- #define EIGEN_USE_MKL_ALL	// to use Intel Math Kernel Library
//		- #include <Eigen/Core>

// GPMap
#include "io/io.hpp"								// loadPointCloud, savePointCloud, loadSensorPositionList
#include "visualization/cloud_viewer.hpp"	// show
#include "features/surface_normal.hpp"		// estimateSurfaceNormals
#include "../macro_gpmap.hpp"					// macro_gpmap
using namespace GPMap;

int main(int argc, char** argv)
{
	// setting
	const size_t NUM_OBSERVATIONS = 4; 
	const std::string strInputDataFolder			("../../data/bunny/input/");
	const std::string strIntermediateDataFolder	("../../data/bunny/intermediate/");
	const std::string strOutputDataFolder			("../../data/bunny/output/");
	const std::string strObsFileNames_[]	= {"bun000", "bun090", "bun180", "bun270"};
	const std::string strFileNameAll			=  "bunny_all";
	StringList strObsFileNames(strObsFileNames_, strObsFileNames_ + NUM_OBSERVATIONS); 

	// log file
	std::string strLogFilePath = strOutputDataFolder + "gpmap.log";
	LogFile logFile;
	logFile.open(strLogFilePath);

	// [1] load/save hit points
	//PointXYZCloudPtrList hitPointCloudPtrList;
	//loadPointCloud<pcl::PointXYZ>(hitPointCloudPtrList, strObsFileNames, strInputDataFolder, ".ply");				// original ply files which are transformed in global coordinates
	//savePointCloud<pcl::PointXYZ>(hitPointCloudPtrList, strObsFileNames, strIntermediateDataFolder, ".pcd");		// original pcd files which are transformed in global coordinates
	//loadPointCloud<pcl::PointXYZ>(hitPointCloudPtrList, strObsFileNames, strIntermediateDataFolder, ".pcd");		// original pcd files which are transformed in global coordinates
	//show<pcl::PointXYZ>("Hit Points", hitPointCloudPtrList);

	//PointXYZCloudPtr pAllHitPointCloud(new PointXYZCloud());
	//for(size_t i = 0; i < hitPointCloudPtrList.size(); i++)	(*pAllHitPointCloud) += (*(hitPointCloudPtrList[i]));
	//savePointCloud<pcl::PointXYZ>(pAllHitPointCloud, strFileNameAll, strIntermediateDataFolder, ".pcd");		// original pcd files which are transformed in global coordinates
	//loadPointCloud<pcl::PointXYZ>(pAllHitPointCloud, strFileNameAll, strIntermediateDataFolder, ".pcd");		// original pcd files which are transformed in global coordinates
	//show<pcl::PointXYZ>("All Hit Points", pAllHitPointCloud);

	// [2] load sensor positions
	//PointXYZVList sensorPositionList;
	//loadSensorPositionList(sensorPositionList, strObsFileNames, strInputDataFolder, "_camera_position.txt");
	//assert(NUM_OBSERVATIONS == hitPointCloudPtrList.size() && NUM_OBSERVATIONS == sensorPositionList.size());

	// [3] load/save function observations
	PointNormalCloudPtrList funcObsCloudPtrList;
	//unitRayBackVectors(hitPointCloudPtrList, sensorPositionList, funcObsCloudPtrList);
	//savePointCloud<pcl::PointNormal>(funcObsCloudPtrList, strObsFileNames, strIntermediateDataFolder, "_func_obs.pcd");
	loadPointCloud<pcl::PointNormal>(funcObsCloudPtrList, strObsFileNames, strIntermediateDataFolder, "_func_obs.pcd");
	//show<pcl::PointNormal>("Unit Ray Back Vectors", funcObsCloudPtrList, 0.005, 0.001);

	PointNormalCloudPtr pAllFuncObs(new PointNormalCloud());
	//for(size_t i = 0; i < funcObsCloudPtrList.size(); i++)	*pAllFuncObs += *funcObsCloudPtrList[i];
	//savePointCloud<pcl::PointNormal>(pAllFuncObs, strFileNameAll, strIntermediateDataFolder, "_func_obs.pcd");
	loadPointCloud<pcl::PointNormal>(pAllFuncObs, strFileNameAll, strIntermediateDataFolder, "_func_obs.pcd");
	//show<pcl::PointNormal>("All Unit Ray Back Vectors", pAllFuncObs, 0.005, 0.001);

	// [4] load/save derivative observations
	PointNormalCloudPtrList derObsCloudPtrList;
	//estimateSurfaceNormals<ByNearestNeighbors>(hitPointCloudPtrList, sensorPositionList, false, 0.01, derObsCloudPtrList);
	//estimateSurfaceNormals<ByMovingLeastSquares>(hitPointCloudPtrList, sensorPositionList, false, 0.01, derObsCloudPtrList);
	//savePointCloud<pcl::PointNormal>(derObsCloudPtrList, strObsFileNames, strIntermediateDataFolder, "_der_obs.pcd");
	loadPointCloud<pcl::PointNormal>(derObsCloudPtrList, strObsFileNames, strIntermediateDataFolder, "_der_obs.pcd");
	//show<pcl::PointNormal>("Surface Normals", derObsCloudPtrList, 0.005, 0.001);

	PointNormalCloudPtr pAllDerObs(new PointNormalCloud());
	//for(size_t i = 0; i < derObsCloudPtrList.size(); i++)	(*pAllDerObs) += (*(derObsCloudPtrList[i]));
	//savePointCloud<pcl::PointNormal>(pAllDerObs, strFileNameAll, strIntermediateDataFolder, "_der_obs.pcd");
	loadPointCloud<pcl::PointNormal>(pAllDerObs, strFileNameAll, strIntermediateDataFolder, "_der_obs.pcd");
	//show<pcl::PointNormal>("All Surface Normals", pAllDerObs, 0.005, 0.001);

	// combinations
	// --------------------------------------------------------
	// |         Observations           |       Process       |
	// |======================================================|
	// |   (FuncObs)  |    (DerObs)     |       | Incremental |
	// | hit points,  |   hit points,   | Batch |-------------|
	// | empty points | surface normals |       | BCM  | iBCM |
	// --------------------------------------------------------

	// [5] GPMap - setting
	// constants
	//const double	BLOCK_SIZE						= 0.003;		// 0.01
	const double	BLOCK_SIZE						= 0.003;		// 0.01
	const size_t	NUM_CELLS_PER_AXIS			= 3;			// 10
	const size_t	MIN_NUM_POINTS_TO_PREDICT	= 3;
	const float		GAP_FOR_FUNC_OBS				= 0.001f;
	const float		GAP_FOR_DER_OBS				= 0.f;
	const bool		FLAG_BCM							= false;
	const bool		FLAG_INDEPENDENT_BCM			= true;
	const int		maxIterBeforeUpdate			= 0;			// 100
	std::string		strFileName;

	// [6] Function Observations
	strFileName = "gpmap_function_observations";
	logFile.open(strOutputDataFolder + strFileName + ".log");
	bool fRunFuncObs;
	logFile << "[Function Observations] - Do you wish to run? (0/1)";
	std::cin >> fRunFuncObs;
	logFile << fRunFuncObs << std::endl;

	if(fRunFuncObs)
	{
		// [6-0] GPMap - function observations - training

		// max iterations and number of random blocks
		int		maxIter;				// 100
		size_t	numRandomBlocks;	// 100, <=0 for all
		logFile << "Learn Function Observations - Max Iterations? (0 for no training): ";
		std::cin >> maxIter;
		logFile << maxIter << std::endl;;
		if(maxIter > 0)
		{
			logFile << "Train - Num Random Blocks? (0 for all) ";	
			std::cin >> numRandomBlocks;
			logFile << numRandomBlocks << std::endl;;
		}

		// hyperparameters
		float sparse_ell, matern_ell, sigma_f, sigma_n;
		bool fUsePredefinedHyperparameters;
		logFile << "Use Predefined Hyperparameters? (0/1) ";
		std::cin >> fUsePredefinedHyperparameters;
		logFile << fUsePredefinedHyperparameters << std::endl;;
		if(fUsePredefinedHyperparameters)
		{
			sparse_ell	= 0.145733f;		// 0.107363f;
			matern_ell	= 0.134403f;		// 0.107363f;
			sigma_f		= 0.370553f;		// 0.99985f;
			sigma_n		= 0.0200443f;		// 0.0034282f;
		}
		else
		{
			std::cout << "sparse_ell: ";			std::cin >> sparse_ell;		// 0.1f
			std::cout << "matern_ell: ";			std::cin >> matern_ell;		// 0.1f
			std::cout << "sigma_f: ";				std::cin >> sigma_f;			// 1.f
			std::cout << "sigma_n: ";				std::cin >> sigma_n;			// 0.1f
		}
		logFile << "sparse_ell: "	<< sparse_ell	<< std::endl;
		logFile << "matern_ell: "	<< matern_ell	<< std::endl;
		logFile << "sigma_f: "		<< sigma_f		<< std::endl;
		logFile << "sigma_n: "		<< sigma_n		<< std::endl;

		// set hyperparameters
		typedef GP::InfExact<float, GP::MeanZero, GP::CovSparseMaterniso, GP::LikGauss>::Hyp HypFuncObs;
		HypFuncObs logHypFuncObs;
		logHypFuncObs.cov(0) = log(sparse_ell);
		logHypFuncObs.cov(1) = log(matern_ell);
		logHypFuncObs.cov(2) = log(sigma_f);
		logHypFuncObs.lik(0) = log(sigma_n);

		// training
		if(maxIter > 0)
		{
			strFileName = "gpmap_function_observations_training";
			logFile.open(strOutputDataFolder + strFileName + ".log");
			gpmap_training<FuncObs,
								GP::MeanZero, 
								GP::CovSparseMaterniso, 
								GP::LikGauss, 
								GP::InfExact>(BLOCK_SIZE,						// block size
												  NUM_CELLS_PER_AXIS,			// number of cells per each axie
												  MIN_NUM_POINTS_TO_PREDICT,	// min number of points to predict
												  logHypFuncObs,					// hyperparameters
												  pAllFuncObs,						// observations
												  GAP_FOR_FUNC_OBS,				// gap
												  maxIter,							// number of iterations for training before update
												  numRandomBlocks);				// number of randomly selected blocks
		}

		// [6-1] GPMap - function observations - batch
		strFileName = "gpmap_function_observations_batch";
		logFile.open(strOutputDataFolder + strFileName + ".log");
		gpmap_batch<FuncObs,
						GP::MeanZero, 
						GP::CovSparseMaterniso, 
						GP::LikGauss, 
						GP::InfExact>(BLOCK_SIZE,						// block size
										  NUM_CELLS_PER_AXIS,			// number of cells per each axie
										  MIN_NUM_POINTS_TO_PREDICT,	// min number of points to predict
										  logHypFuncObs,					// hyperparameters
										  pAllFuncObs,						// observations
										  GAP_FOR_FUNC_OBS,				// gap for free points
										  maxIterBeforeUpdate,			// number of iterations for training before update
										  strOutputDataFolder + strFileName);	// save file path

		// [6-2] GPMap - function observations - incremental(BCM)
		strFileName = "gpmap_function_observations_BCM";
		logFile.open(strOutputDataFolder + strFileName + ".log");
		gpmap_incremental<FuncObs,
								GP::MeanZero, 
								GP::CovSparseMaterniso, 
								GP::LikGauss, 
								GP::InfExact>(BLOCK_SIZE,						// block size
												  NUM_CELLS_PER_AXIS,			// number of cells per each axie
												  MIN_NUM_POINTS_TO_PREDICT,	// min number of points to predict
												  FLAG_BCM,							// independent BCM or BCM
												  logHypFuncObs,					// hyperparameters
												  funcObsCloudPtrList,			// observations
												  GAP_FOR_FUNC_OBS,				// gap for free points
												  maxIterBeforeUpdate,			// number of iterations for training before update
												  strOutputDataFolder + strFileName);	// save file path

		// [6-3] GPMap - function observations - incremental(iBCM)
		strFileName = "gpmap_function_observations_iBCM";
		logFile.open(strOutputDataFolder + strFileName + ".log");
		gpmap_incremental<FuncObs,
								GP::MeanZero, 
								GP::CovSparseMaterniso, 
								GP::LikGauss, 
								GP::InfExact>(BLOCK_SIZE,						// block size
												  NUM_CELLS_PER_AXIS,			// number of cells per each axie
												  MIN_NUM_POINTS_TO_PREDICT,	// min number of points to predict
												  FLAG_INDEPENDENT_BCM,			// independent BCM or BCM
												  logHypFuncObs,					// hyperparameters
												  funcObsCloudPtrList,			// observations
												  GAP_FOR_FUNC_OBS,				// gap for free points
												  maxIterBeforeUpdate,			// number of iterations for training before update
												  strOutputDataFolder + strFileName);	// save file path
	}

	// [7] Derivative Observations
	strFileName = "gpmap_derivative_observations";
	logFile.open(strOutputDataFolder + strFileName + ".log");
	bool fRunDerObs;
	logFile << "[Derivative Observations] - Do you wish to run? (0/1)";
	std::cin >> fRunDerObs;
	logFile << fRunDerObs << std::endl;

	if(fRunDerObs)
	{
		// [7-0] GPMap - derivative observations - traininig

		// max iterations and number of random blocks
		int		maxIter;				// 100
		size_t	numRandomBlocks;	// 100, <=0 for all
		logFile << "Learn Function Observations - Max Iterations (0 for no training): ";
		std::cin >> maxIter;
		logFile << maxIter << std::endl;;
		if(maxIter > 0)
		{
			logFile << "Train - Num Random Blocks? (0 for all) ";	
			std::cin >> numRandomBlocks;
			logFile << numRandomBlocks << std::endl;;
		}

		// hyperparameters
		float sparse_ell, matern_ell, sigma_f, sigma_n, sigma_nd;
		bool fUsePredefinedHyperparameters;
		logFile << "Use Predefined Hyperparameters? (0/1) ";
		std::cin >> fUsePredefinedHyperparameters;
		logFile << fUsePredefinedHyperparameters << std::endl;;
		if(fUsePredefinedHyperparameters)
		{
			sparse_ell	= 0.145733f;		// 0.107363f;
			matern_ell	= 0.134403f;		// 0.107363f;
			sigma_f		= 0.370553f;		// 0.99985f;
			sigma_n		= 0.0200443f;		// 0.0034282f;
			sigma_nd		= 0.200443f;		// 0.0990157f;
		}
		else
		{
			std::cout << "sparse_ell: ";			std::cin >> sparse_ell;		// 0.1f
			std::cout << "matern_ell: ";			std::cin >> matern_ell;		// 0.1f
			std::cout << "sigma_f: ";				std::cin >> sigma_f;			// 1.f
			std::cout << "sigma_n: ";				std::cin >> sigma_n;			// 0.1f
			std::cout << "sigma_nd: ";				std::cin >> sigma_nd;		// 0.1f
		}
		logFile << "sparse_ell: "	<< sparse_ell	<< std::endl;
		logFile << "matern_ell: "	<< matern_ell	<< std::endl;
		logFile << "sigma_f: "		<< sigma_f		<< std::endl;
		logFile << "sigma_n: "		<< sigma_n		<< std::endl;
		logFile << "sigma_nd: "		<< sigma_nd		<< std::endl;

		// set hyperparameters
		typedef GP::InfExactDerObs<float, GP::MeanZeroDerObs, GP::CovSparseMaternisoDerObs, GP::LikGaussDerObs>::Hyp HypDerObs;
		HypDerObs logHypDerObs;
		logHypDerObs.cov(0) = log(sparse_ell);
		logHypDerObs.cov(1) = log(matern_ell);
		logHypDerObs.cov(2) = log(sigma_f);
		logHypDerObs.lik(0) = log(sigma_n);
		logHypDerObs.lik(1) = log(sigma_nd);

		// training
		if(maxIter > 0)
		{
			strFileName = "gpmap_derivative_observations_training";
			logFile.open(strOutputDataFolder + strFileName + ".log");
			gpmap_training<DercObs,
								GP::MeanZeroDerObs, 
								GP::CovSparseMaternisoDerObs, 
								GP::LikGaussDerObs, 
								GP::InfExactDerObs>(BLOCK_SIZE,						// block size
														  NUM_CELLS_PER_AXIS,			// number of cells per each axie
														  MIN_NUM_POINTS_TO_PREDICT,	// min number of points to predict
														  logHypDerObs,					// hyperparameters
														  pAllDerObs,						// observations
														  GAP_FOR_DER_OBS,				// gap
														  maxIter,							// number of iterations for training before update
														  numRandomBlocks);				// number of randomly selected blocks
		}

		// [7-1] GPMap - derivative observations - batch
		strFileName = "gpmap_derivative_observations_batch";
		logFile.open(strOutputDataFolder + strFileName + ".log");
		gpmap_batch<DercObs,
						GP::MeanZeroDerObs, 
						GP::CovSparseMaternisoDerObs, 
						GP::LikGaussDerObs, 
						GP::InfExactDerObs>(BLOCK_SIZE,						// block size
												  NUM_CELLS_PER_AXIS,			// number of cells per each axie
												  MIN_NUM_POINTS_TO_PREDICT,	// min number of points to predict
												  logHypDerObs,					// hyperparameters
												  pAllDerObs,						// observations
												  GAP_FOR_DER_OBS,				// gap for free points
												  maxIterBeforeUpdate,			// number of iterations for training before update
												  strOutputDataFolder + strFileName);	// save file path

		// [7-2] GPMap - derivative observations - incremental(BCM)
		strFileName = "gpmap_derivative_observations_BCM";
		logFile.open(strOutputDataFolder + strFileName + ".log");
		gpmap_incremental<DercObs,
								GP::MeanZeroDerObs, 
								GP::CovSparseMaternisoDerObs, 
								GP::LikGaussDerObs, 
								GP::InfExactDerObs>(BLOCK_SIZE,						// block size
														  NUM_CELLS_PER_AXIS,			// number of cells per each axie
														  MIN_NUM_POINTS_TO_PREDICT,	// min number of points to predict
														  FLAG_BCM,							// independent BCM or BCM
														  logHypDerObs,					// hyperparameters
														  derObsCloudPtrList,			// observations
														  GAP_FOR_DER_OBS,				// gap for free points
														  maxIterBeforeUpdate,			// number of iterations for training before update
														  strOutputDataFolder + strFileName);	// save file path

		// [7-3] GPMap - derivative observations - incremental(iBCM)
		strFileName = "gpmap_derivative_observations_iBCM";
		logFile.open(strOutputDataFolder + strFileName + ".log");
		gpmap_incremental<DercObs,
								GP::MeanZeroDerObs, 
								GP::CovSparseMaternisoDerObs, 
								GP::LikGaussDerObs, 
								GP::InfExactDerObs>(BLOCK_SIZE,						// block size
														  NUM_CELLS_PER_AXIS,			// number of cells per each axie
														  MIN_NUM_POINTS_TO_PREDICT,	// min number of points to predict
														  FLAG_INDEPENDENT_BCM,			// independent BCM or BCM
														  logHypDerObs,					// hyperparameters
														  derObsCloudPtrList,			// observations
														  GAP_FOR_DER_OBS,				// gap for free points
														  maxIterBeforeUpdate,			// number of iterations for training before update
														  strOutputDataFolder + strFileName);	// save file path
	}

	system("pause");
}

#endif
#ifndef _OCTREE_GAUSSIAN_PROCESS_HPP_
#define _OCTREE_GAUSSIAN_PROCESS_HPP_

// STL
#include <cmath>			// floor, ceil
#include <vector>

// PCL
#include <pcl/point_types.h>
#include <pcl/octree/octree.h>
#include <pcl/octree/octree_impl.h>

// Eigen
#include <Eigen/Dense>

// Boost
#include "boost/tuple/tuple.hpp"

// OpenGP
#include "GP.h"

// GPMap
#include "util/util.hpp"						// min max
#include "octree/octree_container.hpp"		// GPMapDataT, GPMapLeafT
#include "data/test_data.hpp"					// meshGrid

namespace GPMap {

// data types
typedef pcl::PointXYZ																								GPMapPointT;
typedef pcl::octree::OctreeContainerEmpty<GPMapDataT>														GPMapBranchT;
typedef pcl::octree::OctreeBase<GPMapDataT, GPMapLeafT, GPMapBranchT>								GPMapOctreeT;
typedef pcl::octree::OctreePointCloud<GPMapPointT, GPMapLeafT, GPMapBranchT, GPMapOctreeT>	OctreePointXYZCloud;

class OctreePointCloud_GP : protected OctreePointXYZCloud
{
	// iterators are friends
	friend class pcl::octree::OctreeIteratorBase<GPMapDataT, GPMapOctreeT>;
	friend class pcl::octree::OctreeDepthFirstIterator<GPMapDataT, GPMapOctreeT>;
	friend class pcl::octree::OctreeBreadthFirstIterator<GPMapDataT, GPMapOctreeT>;
	friend class pcl::octree::OctreeLeafNodeIterator<GPMapDataT, GPMapOctreeT>;

public:
	// Octree iterators
	typedef pcl::octree::OctreeDepthFirstIterator<GPMapDataT, GPMapOctreeT>				Iterator;
	typedef const pcl::octree::OctreeDepthFirstIterator<GPMapDataT, GPMapOctreeT>		ConstIterator;

	typedef pcl::octree::OctreeLeafNodeIterator<GPMapDataT, GPMapOctreeT>				LeafNodeIterator;
	typedef const pcl::octree::OctreeLeafNodeIterator<GPMapDataT, GPMapOctreeT>		ConstLeafNodeIterator;

	typedef pcl::octree::OctreeDepthFirstIterator<GPMapDataT, GPMapOctreeT>				DepthFirstIterator;
	typedef const pcl::octree::OctreeDepthFirstIterator<GPMapDataT, GPMapOctreeT>		ConstDepthFirstIterator;
	typedef pcl::octree::OctreeBreadthFirstIterator<GPMapDataT, GPMapOctreeT>			BreadthFirstIterator;
	typedef const pcl::octree::OctreeBreadthFirstIterator<GPMapDataT, GPMapOctreeT>	ConstBreadthFirstIterator;

	public:
	/** @brief Constructor
	*  @param resolution: octree resolution at lowest octree level
    */
   OctreePointCloud_GP(const double blockSize, const size_t nCellsPerBlock, const pcl::PointXYZ &min_pt, const pcl::PointXYZ &max_pt)
		: OctreePointXYZCloud(blockSize),
		  //fBoundingBoxInitialized(false),
		  m_pHitPointCloud(input_),
		  m_blockSize(blockSize),
		  m_nCellsPerBlock(nCellsPerBlock),
		  m_fDuplicatePointIndexToNeighboringVoxels(true),
		  m_pXs(new Matrix(nCellsPerBlock*nCellsPerBlock*nCellsPerBlock, 3))
   {
		assert(nCellsPerBlock > 0);

		// bounding box
		double minX, minY, minZ, maxX, maxY, maxZ;
		minX = floor(static_cast<double>(min_pt.x)/blockSize - 1.f)*blockSize;
		minY = floor(static_cast<double>(min_pt.y)/blockSize - 1.f)*blockSize;
		minZ = floor(static_cast<double>(min_pt.z)/blockSize - 1.f)*blockSize;
		maxX = ceil (static_cast<double>(max_pt.x)/blockSize + 1.f)*blockSize;
		maxY = ceil (static_cast<double>(max_pt.y)/blockSize + 1.f)*blockSize;
		maxZ = ceil (static_cast<double>(max_pt.z)/blockSize + 1.f)*blockSize;
		defineBoundingBox(minX, minY, minZ, maxX, maxY, maxZ);

		// set the test positions at (0, 0, 0)
		meshGrid(Eigen::Vector3f(0.f, 0.f, 0.f), 
					nCellsPerBlock, 
					static_cast<float>(blockSize) / static_cast<float>(nCellsPerBlock),
					m_pXs);
   }

	/** @brief Empty class constructor */
	virtual ~OctreePointCloud_GP()
	{
	}

   /** @brief Provide a pointer to the input data set.
	  * @details	Refer to pcl::octree::OctreePointCloud<PointT, LeafT, BranchT, OctreeT>
	  *				::setInputCloud(const PointCloudConstPtr &cloud_arg, const IndicesConstPtr &indices_arg = IndicesConstPtr ())
	  *				where assertion is activated when this->leafCount_!=0.
     * @param[in] pCloud the const boost shared pointer to a PointCloud message
     * @param[in] pIndices the point indices subset that is to be used from \a cloud - if 0 the whole point cloud is used
    */
   void setInputCloud(const PointXYZCloudConstPtr		&pHitPointCloud,
							 const PointXYZCloudConstPtr		&pEmptyPointCloud,
							 const PointNormalCloudConstPtr	&pSurfaceNormalCloud)
   {
      //assert(this->leafCount_==0);

		// set the input cloud
		m_pHitPointCloud				= pHitPointCloud;
		m_pEmptyPointCloud			= pEmptyPointCloud;
		m_pSurfaceNormalCloud		= pSurfaceNormalCloud;

		indices_ = IndicesConstPtr();
   }

	/** @brief Add points from input point cloud to octree.
	  * @details	Refer to pcl::octree::OctreePointCloud<PointT, LeafT, BranchT, OctreeT>::addPointsFromInputCloud()
	  *				where assertion is activated when this->leafCount_!=0.
	  */
	void addPointsFromInputCloud()
	{
		// assert (this->leafCount_==0);

		// reset the previous point indices in each voxel
		reset();

		// min/max of the new observations
		pcl::PointXYZ		minHitPointXYZ,	maxHitPointXYZ;
		pcl::PointXYZ		minEmptyPointXYZ,	maxEmptyPointXYZ;
		pcl::PointNormal	minSurfaceNormal,	maxSurfaceNormal;

		pcl::getMinMax3D(*m_pHitPointCloud,			minHitPointXYZ,	maxHitPointXYZ);
		pcl::getMinMax3D(*m_pEmptyPointCloud,		minEmptyPointXYZ, maxEmptyPointXYZ);
		pcl::getMinMax3D(*m_pSurfaceNormalCloud,	minSurfaceNormal, maxSurfaceNormal);

		// min/max of them
		pcl::PointXYZ min_pt = min(min(minHitPointXYZ, minEmptyPointXYZ), minSurfaceNormal);
		pcl::PointXYZ max_pt = max(max(maxHitPointXYZ, maxEmptyPointXYZ), maxSurfaceNormal);

		min_pt.x -= m_blockSize;
		min_pt.y -= m_blockSize;
		min_pt.z -= m_blockSize;
		max_pt.x += m_blockSize;
		max_pt.y += m_blockSize;
		max_pt.z += m_blockSize;

		// adopt the bounding box
		adoptBoundingBoxToPoint(min_pt);
		adoptBoundingBoxToPoint(max_pt);

		// add the new hit points
		if(m_pHitPointCloud)
			for(int i = 0; i < m_pHitPointCloud->points.size(); i++)
				if(isFinite(m_pHitPointCloud->points[i]))
					this->addPointIdx(GPMapDataT(HIT_POINT, i));

		// add the new empty points
		if(m_pEmptyPointCloud)
			for(int i = 0; i < m_pEmptyPointCloud->points.size(); i++)
				if(isFinite(m_pEmptyPointCloud->points[i]))
					this->addPointIdx(GPMapDataT(EMPTY_POINT, i));

		// add the new surface normal vectors
		if(m_pSurfaceNormalCloud)
			for(int i = 0; i < m_pSurfaceNormalCloud->points.size(); i++)
				if(isFinite(m_pSurfaceNormalCloud->points[i]))
					this->addPointIdx(GPMapDataT(SURFACE_NORMAL, i));
	}


	/** @brief		Update the GPMap with new observations */
	void update()
	{
		//// if a point index is duplicated to 
		//if(m_fDuplicatePointIndexToNeighboringVoxels)
		//{
		//	// leaf node iterator
		//	LeafNodeIterator iter(*this);

		//	// for each leaf node
		//	while(*++iter)
		//	{
		//		// predict
		//		GPMapLeafT *pLeafNode = static_cast<GPMapLeafT*>(iter.getCurrentOctreeNode());
		//		pLeafNode->update(*input_);
		//	}
		//}
		//else
		//{
		//	// create empty neigboring blocks if necessary
		//	createEmptyNeigboringBlocks();

		//	// leaf node iterator
		//	LeafNodeIterator iter(*this);

		//	// for each leaf node
		//	while(*++iter)
		//	{
		//		// key
		//		const pcl::octree::OctreeKey &key = iter.getCurrentOctreeKey();

		//		// collect indices
		//		std::vector<int> indexVector;
		//		for(int deltaX = -1; deltaX <= 1; deltaX++)
		//			for(int deltaY = -1; deltaY <= 1; deltaY++)
		//				for(int deltaZ = -1; deltaZ <= 1; deltaZ++)
		//				{
		//					getData(pcl::octree::OctreeKey(key.x+deltaX, key.y+deltaY, key.z+deltaZ), indexVector);
		//				}

		//		// predict
		//		GPMapLeafT *pLeafNode = static_cast<GPMapLeafT*>(iter.getCurrentOctreeNode());
		//		pLeafNode->update(*input_, indexVector);
		//	}
		//}
	}

	/** @brief Get occupied voxel centers */
	/** @brief		Get occupied voxel center points
	  * @details	Refer to pcl::octree::OctreePointCloud<PointT, LeafT, BranchT, OctreeT>::getOccupiedVoxelCenters(AlignedPointTVector &voxelCenterList_arg) const
	  *				which only accept a vector of PointT points, not pcl::PointXYZ.
	  *				Thus, even if the octree has pcl::PointNormals, the center point should also be pcl::PointXYZ.
	  */
	size_t getOccupiedVoxelCenters(PointXYZVector	&voxelCenterPointXYZVector,
											const bool			fRemoveIsolatedVoxels) const
	{
		// clear the vector
		voxelCenterPointXYZVector.clear();

		// shift key
		pcl::octree::OctreeKey key(0, 0, 0);

		// search for occupied voxels recursively
		return getOccupiedVoxelCentersRecursive(this->rootNode_, key, voxelCenterPointXYZVector, fRemoveIsolatedVoxels);
	}

	/** @brief Get the total number of point indices stored in each voxel */
	size_t totalNumOfPointIndices()
	{
		// size
		size_t n(0);

		// leaf node iterator
		LeafNodeIterator iter(*this);

		// for each leaf node
		while(*++iter)
		{
			// predict
			GPMapLeafT *pLeafNode = static_cast<GPMapLeafT*>(iter.getCurrentOctreeNode());
			n += pLeafNode->getSize();
		}

		return n;
	}

protected:

	/** @brief Reset the points in each voxel */
	void reset()
	{
		// leaf node iterator
		LeafNodeIterator iter(*this);

		// for each leaf node
		while(*++iter)
		{
			// predict
			GPMapLeafT *pLeafNode = static_cast<GPMapLeafT*>(iter.getCurrentOctreeNode());
			pLeafNode->reset();
		}
	}

	/** @brief		Add a point from input cloud to the corresponding voxel and neighboring ones
	  * @details	Refer to pcl::octree::OctreePointCloud<PointT, LeafT, BranchT, OctreeT>::addPointIdx (const int pointIdx_arg)
	  *				which add the point to the corresponding voxel only.
	  */
	void addPointIdx(const GPMapDataT &data)
	{
		// check the index range
		//assert(pointIdx < static_cast<int>(input_->points.size()));
	
		// point
		pcl::PointXYZ point;
		const int pointIdx(data.get<1>());
		switch(data.get<0>())
		{
		case HIT_POINT:
			{
				point.x = m_pHitPointCloud->points[pointIdx].x;
				point.y = m_pHitPointCloud->points[pointIdx].y;
				point.z = m_pHitPointCloud->points[pointIdx].z;
				break;
			}
		case EMPTY_POINT:
			{
				point.x = m_pEmptyPointCloud->points[pointIdx].x;
				point.y = m_pEmptyPointCloud->points[pointIdx].y;
				point.z = m_pEmptyPointCloud->points[pointIdx].z;
				break;
			}
		case SURFACE_NORMAL:
			{
				point.x = m_pSurfaceNormalCloud->points[pointIdx].x;
				point.y = m_pSurfaceNormalCloud->points[pointIdx].y;
				point.z = m_pSurfaceNormalCloud->points[pointIdx].z;
				break;
			}
		}
		
		// make sure bounding box is big enough
		if(m_fDuplicatePointIndexToNeighboringVoxels)
		{
			pcl::PointXYZ min_pt(point), max_pt(point);
			min_pt.x -= m_blockSize;
			min_pt.y -= m_blockSize;
			min_pt.z -= m_blockSize;
			max_pt.x += m_blockSize;
			max_pt.y += m_blockSize;
			max_pt.z += m_blockSize;
			adoptBoundingBoxToPoint(min_pt);
			adoptBoundingBoxToPoint(max_pt);
		}
		else
			adoptBoundingBoxToPoint(point);
		
		// key
		pcl::octree::OctreeKey key;
		genOctreeKeyforPoint(point, key);
		
		// add point to octree at key
		if(m_fDuplicatePointIndexToNeighboringVoxels)
		{
			for(int deltaX = -1; deltaX <= 1; deltaX++)
				for(int deltaY = -1; deltaY <= 1; deltaY++)
					for(int deltaZ = -1; deltaZ <= 1; deltaZ++)
						this->addData(pcl::octree::OctreeKey(key.x+deltaX, key.y+deltaY, key.z+deltaZ), data);
		}
		else
			this->addData(key, data);
	}

	/** @brief Create empty neighboring blocks for each occupied block if necessary */
	void createEmptyNeigboringBlocks()
	{
		// leaf node iterator
		LeafNodeIterator iter(*this);

		// for each leaf node
		while(*++iter)
		{
			// key
			const pcl::octree::OctreeKey &key = iter.getCurrentOctreeKey();

			// add -1 index to the neighboring leaf nodes
			for(int deltaX = -1; deltaX <= 1; deltaX++)
				for(int deltaY = -1; deltaY <= 1; deltaY++)
					for(int deltaZ = -1; deltaZ <= 1; deltaZ++)
					{
						if(deltaX == 0 && deltaY == 0 && deltaZ == 0) continue;
						addData(pcl::octree::OctreeKey(key.x+deltaX, key.y+deltaY, key.z+deltaZ), GPMapDataT(NO_OBSERVATION, -1));
					}
		}
	}


	/** @brief Get the maximum octree key */
	void getMaxKey(pcl::octree::OctreeKey &key) const
	{
		// calculate unsigned integer octree key
		//key.x = static_cast<unsigned int>((this->maxX_ - this->minX_) / this->resolution_);
		//key.y = static_cast<unsigned int>((this->maxY_ - this->minY_) / this->resolution_);
		//key.z = static_cast<unsigned int>((this->maxZ_ - this->minZ_) / this->resolution_);
		key = maxKey_;
	}

	///** @brief Get the point indices in the leaf node corresponding the octree key */
	//bool getData(const pcl::octree::OctreeKey &key, std::vector<int> &indexVector) const
	//{
	//	// leaf node corresponding the octree key
	//	LeafT* pLeaf = findLeaf(key);

	//	// if the leaf node exists, add point indices to the vector
	//	if(pLeaf)
	//	{
	//		pLeaf->getData(indexVector);
	//		return true;
	//	}
	//	return false;
	//}

	/** @brief Get the min max points of the voxel corresponding the octree key */
	void genVoxelBounds(const pcl::octree::OctreeKey &key, Eigen::Vector3f &min_pt, Eigen::Vector3f &max_pt) const 
	{
		// calculate voxel bounds
		min_pt(0) = static_cast<float>(static_cast<double>(key.x) * this->resolution_ + this->minX_);
		min_pt(1) = static_cast<float>(static_cast<double>(key.y) * this->resolution_ + this->minY_);
		min_pt(2) = static_cast<float>(static_cast<double>(key.z) * this->resolution_ + this->minZ_);

		max_pt(0) = static_cast<float>(static_cast<double>(key.x + 1) * this->resolution_ + this->minX_);
		max_pt(1) = static_cast<float>(static_cast<double>(key.y + 1) * this->resolution_ + this->minY_);
		max_pt(2) = static_cast<float>(static_cast<double>(key.z + 1) * this->resolution_ + this->minZ_);
	}

	/** @brief		Get the center point of the voxel corresponding the octree key
	  * @details	Refer to pcl::octree::OctreePointCloud<PointT, LeafT, BranchT, OctreeT>::genLeafNodeCenterFromOctreeKey(const OctreeKey & key, PointT & point) const
	  *				which only accept PointT point, not pcl::PointXYZ.
	  *				Thus, even if the octree has pcl::PointNormals, the center point should also be pcl::PointXYZ.
	  */
	void genLeafNodeCenterPointXYZ(const pcl::octree::OctreeKey &key, pcl::PointXYZ &point) const
	{
		// define point to leaf node voxel center
		point.x = static_cast<float>((static_cast<double>(key.x) + 0.5) * this->resolution_ + this->minX_);
		point.y = static_cast<float>((static_cast<double>(key.y) + 0.5) * this->resolution_ + this->minY_);
		point.z = static_cast<float>((static_cast<double>(key.z) + 0.5) * this->resolution_ + this->minZ_);
	}

	/** @brief		Get the occupied voxel center points
	  * @details	Refer to pcl::octree::OctreePointCloud<PointT, LeafT, BranchT, OctreeT>::getOccupiedVoxelCentersRecursive(const BranchNode* node_arg, const OctreeKey& key_arg, AlignedPointXYZVector &voxelCenterList_arg) const
	  *				which only accept a vector of PointT points, not pcl::PointXYZ.
	  *				Thus, even if the octree has pcl::PointNormals, the center point should also be pcl::PointXYZ.
	  */
	size_t getOccupiedVoxelCentersRecursive(const BranchNode	*node,
														 const pcl::octree::OctreeKey		&key,
														 PointXYZVector						&voxelCenterPointXYZVector,
														 const bool								fRemoveIsolatedVoxels) const
	{
		// voxel count
		size_t voxelCount = 0;
		
		// iterate over all children
		for(unsigned char childIdx = 0; childIdx < 8; childIdx++)
		{
			if (!this->branchHasChild(*node, childIdx)) continue;
			
			const pcl::octree::OctreeNode *childNode;
			childNode = this->getBranchChildPtr(*node, childIdx);
			
			// generate new key for current branch voxel
			pcl::octree::OctreeKey newKey;
			newKey.x = (key.x << 1) | (!!(childIdx & (1 << 2)));
			newKey.y = (key.y << 1) | (!!(childIdx & (1 << 1)));
			newKey.z = (key.z << 1) | (!!(childIdx & (1 << 0)));
			
			// for each node type
			switch(childNode->getNodeType())
			{
				// if this node is a branch node, go deeper recursively
				case pcl::octree::BRANCH_NODE:
				{
					// recursively proceed with indexed child branch
					voxelCount += getOccupiedVoxelCentersRecursive(static_cast<const BranchNode*>(childNode), newKey, voxelCenterPointXYZVector, fRemoveIsolatedVoxels);
					break;
				}
				
				// if this node is a leaf node, check if it is not isolated and add the center point
				case pcl::octree::LEAF_NODE:
				{
					// if it is an isolated voxel, do not add its center point
					if(fRemoveIsolatedVoxels && !isNotIsolatedVoxel(newKey)) break;

					// calculate the center point and add it to the vector
					pcl::PointXYZ newPoint;
					genLeafNodeCenterPointXYZ(newKey, newPoint);
					voxelCenterPointXYZVector.push_back(newPoint);
					voxelCount++;
					break;
				}
				
				default:
					break;
			}
		}
		
		return voxelCount;
	}

	bool isNotIsolatedVoxel(const pcl::octree::OctreeKey &key) const
	{
		// if it is on the boundary
		// TODO: maxKey_
		if(key.x == 0 || key.y == 0 || key.z == 0 ||
			key.x >= maxKey_.x || key.y >= maxKey_.y || key.z >= maxKey_.z) return true;

		// check if the node is surrounded with occupied nodes
		if(!existLeaf(key.x+1, key.y,   key.z  ))		return true;
		if(!existLeaf(key.x-1, key.y,   key.z  ))		return true;
		if(!existLeaf(key.x,   key.y+1, key.z  ))		return true;
		if(!existLeaf(key.x,   key.y-1, key.z  ))		return true;
		if(!existLeaf(key.x,   key.y,   key.z+1))		return true;
		if(!existLeaf(key.x,   key.y,   key.z-1))		return true;

		return false;
	}

protected:
	/** @brief Pointer to input point cloud dataset. */
	PointXYZCloudConstPtr		&m_pHitPointCloud;
	PointXYZCloudConstPtr		m_pEmptyPointCloud;
	PointNormalCloudConstPtr	m_pSurfaceNormalCloud;

	///** @brief		Check if this is first observation or not */
	//bool				fBoundingBoxInitialized;

	/** @brief		Flag for duplicating a point index to neighboring voxels 
	  * @details	If it is duplicated, prediction will be easy without considering neighboring voxels,
	  *				but the total memory size for indices will be 27 times bigger. */
	const bool		m_fDuplicatePointIndexToNeighboringVoxels;

	/** @brief Size of each block (voxel) */
	const double	m_blockSize;
	
	/** @brief		Number of cells per a block
	  * @details	Note that each block(voxel) has a number of cells.
	  *				The block size corresponds to the resolution of voxels in pcl::octree::OctreePointCloud
	  */
	const size_t m_nCellsPerBlock;

	/** @brief		Test inputs of a block whose minimum point is (0, 0, 0) */
	MatrixPtr	m_pXs;
};
 

}

#endif
#ifndef _OCTREE_VIEWER_HPP_
#define _OCTREE_VIEWER_HPP_

#include <pcl/io/pcd_io.h>

#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/visualization/point_cloud_handlers.h>
#include <pcl/visualization/common/common.h>

#include <pcl/octree/octree.h>
#include <pcl/octree/octree_impl.h>

#include <pcl/filters/filter.h>

namespace GPMap {

//=============================
// Displaying cubes is very long!
// so we limit their numbers.
//const int MAX_DISPLAYED_CUBES(15000);
const int MAX_DISPLAYED_CUBES(1500000);
//=============================

template <typename PointT, typename Octree>
class OctreeViewer
{
	typedef pcl::octree::OctreePointCloudVoxelCentroid<PointT> MyOctree;

public:
	OctreeViewer(const typename pcl::PointCloud<PointT>::Ptr pPointCloud, double resolution)
		: viz("Octree visualizator"),
		  m_pOriginalPointCloud(pPointCloud),
		  m_pVoxelCenterPointCloud(new pcl::PointCloud<pcl::PointXYZ>()),
		  m_octree(resolution),
		  m_fDrawCubes(true),
		  m_fDisplayPointsWithCubes(true),
		  m_fWireframe(true)
	{
		//try to load the cloud
		if(!loadCloud())	return;
		
		//register keyboard callbacks
		viz.registerKeyboardCallback(&OctreeViewer::keyboardEventOccurred, *this, 0);
		
		//key legends
		viz.addText("Keys:", 0, 170, 0.0, 1.0, 0.0, "keys_t");
		viz.addText("a -> Increment displayed depth", 10, 155, 0.0, 1.0, 0.0, "key_a_t");
		viz.addText("z -> Decrement displayed depth", 10, 140, 0.0, 1.0, 0.0, "key_z_t");
		viz.addText("d -> Toggle Point/Cube representation", 10, 125, 0.0, 1.0, 0.0, "key_d_t");
		viz.addText("x -> Show/Hide original cloud", 10, 110, 0.0, 1.0, 0.0, "key_x_t");
		viz.addText("s/w -> Surface/Wireframe representation", 10, 95, 0.0, 1.0, 0.0, "key_sw_t");
		
		//set current level to half the maximum one
		displayedDepth = static_cast<int> (floor(m_octree.getTreeDepth() / 2.0));
		if (displayedDepth == 0) displayedDepth = 1;
		
		//show m_octree at default depth
		extractPointsAtLevel(displayedDepth);
		
		//reset camera
		viz.resetCameraViewpoint("cloud");
		
		//run main loop
		run();
	}


  //========================================================

	/* @brief Callback to interact with the keyboard */
	void keyboardEventOccurred(const pcl::visualization::KeyboardEvent &event, void *)
	{
		if			(event.getKeySym() == "a" && event.keyDown())	IncrementLevel();
		else if	(event.getKeySym() == "z" && event.keyDown())	DecrementLevel();
		else if	(event.getKeySym() == "d" && event.keyDown())	{ m_fDrawCubes = !m_fDrawCubes; update(); }
		else if	(event.getKeySym() == "x" && event.keyDown())	{ m_fDisplayPointsWithCubes = !m_fDisplayPointsWithCubes; update(); }
		else if	(event.getKeySym() == "w" && event.keyDown())	{ if(!m_fWireframe) m_fWireframe=true;	update(); }
		else if	(event.getKeySym() == "s" && event.keyDown())	{ if(m_fWireframe)	m_fWireframe=false;	update(); }
	}
	
	
	/* @brief Graphic loop for the viewer */
	void run()
	{
		while (!viz.wasStopped())
		{
			//main loop of the visualizer
			viz.spinOnce(100);
			boost::this_thread::sleep(boost::posix_time::microseconds(100000));
		}
	}

	/* @brief Helper function that read a pointcloud file (returns false if pbl) Also initialize the octree */
	bool loadCloud()
	{
		//create octree structure
		m_octree.setInputCloud(m_pOriginalPointCloud);

		//update bounding box automatically
		m_octree.defineBoundingBox();

		//add points in the tree
		m_octree.addPointsFromInputCloud();
		return true;
	}

	/* @brief Helper function that draw info for the user on the viewer */
	void displayLegend(const bool fDrawCubes)
	{
		// cubes or points
		char dataDisplay[256];
		sprintf(dataDisplay, "Displaying data as %s", (fDrawCubes) ? ("CUBES") : ("POINTS"));
		viz.removeShape("disp_t");
		viz.addText(dataDisplay, 0, 60, 1.0, 0.0, 0.0, "disp_t");
		
		// depth level
		char level[256];
		sprintf(level, "Displayed depth is %d on %d", displayedDepth, m_octree.getTreeDepth());
		viz.removeShape("level_t1");
		viz.addText(level, 0, 45, 1.0, 0.0, 0.0, "level_t1");

		// voxel size
		viz.removeShape("level_t2");
		sprintf(level, "Voxel size: %.4fm [%zu voxels]", sqrt(m_octree.getVoxelSquaredSideLen(displayedDepth)),
																		 m_pVoxelCenterPointCloud->points.size());
		viz.addText(level, 0, 30, 1.0, 0.0, 0.0, "level_t2");

		// original points
		viz.removeShape("org_t");
		if (m_fDisplayPointsWithCubes) viz.addText("Displaying original cloud", 0, 15, 1.0, 0.0, 0.0, "org_t");
	}

	/* @brief Visual update. Create visualizations and add them to the viewer */
	void update()
	{
		// remove existing shapes from visualizer
		clearView();
		
		// prevent the display of too many cubes
		bool fDrawCubes = m_fDrawCubes && static_cast<int> (m_pVoxelCenterPointCloud->points.size ()) <= MAX_DISPLAYED_CUBES;
		
		// display legend
		displayLegend(fDrawCubes);

		// draw voxels
		if(fDrawCubes)
		{
			//draw octree as cubes
			drawCubes(sqrt(m_octree.getVoxelSquaredSideLen(displayedDepth)));
			
			// display original points with cubes
			if (m_fDisplayPointsWithCubes)
			{
				//add original cloud in visualizer
				pcl::visualization::PointCloudColorHandlerGenericField<PointT> hColor(m_pOriginalPointCloud, "z");
				viz.addPointCloud<PointT>(m_pOriginalPointCloud, hColor, "cloud");
			}
		}

		// display voxel center points
		else
		{
			//add current cloud in visualizer
			pcl::visualization::PointCloudColorHandlerGenericField<PointXYZ> hColor(m_pVoxelCenterPointCloud,"z");
			viz.addPointCloud<PointXYZ>(m_pVoxelCenterPointCloud, hColor, "cloud");
		}
	}
	
	/* @brief remove dynamic objects from the viewer */
	void clearView()
	{
		//remove cubes if any
		vtkRenderer *renderer = viz.getRenderWindow()->GetRenderers()->GetFirstRenderer();
		while(renderer->GetActors()->GetNumberOfItems() > 0)
			renderer->RemoveActor(renderer->GetActors()->GetLastActor());
		
		//remove point clouds if any
		viz.removePointCloud("cloud");
	}
	
	/* @brief Create a vtkSmartPointer object containing a cube */
	vtkSmartPointer<vtkPolyData> GetCuboid(double minX, double maxX, double minY, double maxY, double minZ, double maxZ)
	{
		vtkSmartPointer<vtkCubeSource> cube = vtkSmartPointer<vtkCubeSource>::New();
		cube->SetBounds(minX, maxX, minY, maxY, minZ, maxZ);
		return cube->GetOutput();
	}
	
	/* @brief display octree cubes via vtk-functions */
	void drawCubes(const double voxelSideLen)
	{
		//get the renderer of the visualizer object
		vtkRenderer *renderer = viz.getRenderWindow()->GetRenderers()->GetFirstRenderer();

		// poly data
		vtkSmartPointer<vtkAppendPolyData> treeWireframe = vtkSmartPointer<vtkAppendPolyData>::New();

		// create cubes for each voxel center point with a fixed size
		const double s = voxelSideLen / 2.0;
		for (size_t i = 0; i < m_pVoxelCenterPointCloud->points.size(); i++)
		{
			const double x = m_pVoxelCenterPointCloud->points[i].x;
			const double y = m_pVoxelCenterPointCloud->points[i].y;
			const double z = m_pVoxelCenterPointCloud->points[i].z;
			
			treeWireframe->AddInput(GetCuboid(x - s, x + s, y - s, y + s, z - s, z + s));
		}

		// tree actor
		vtkSmartPointer<vtkActor> treeActor = vtkSmartPointer<vtkActor>::New();

		// dataset mapper
		vtkSmartPointer<vtkDataSetMapper> mapper = vtkSmartPointer<vtkDataSetMapper>::New();
		mapper->SetInput(treeWireframe->GetOutput());
		treeActor->SetMapper(mapper);
		
		// color, line width and wireframe/surface
		treeActor->GetProperty()->SetColor(1.0, 1.0, 1.0);
		treeActor->GetProperty()->SetLineWidth(2);
		if(m_fWireframe)
		{
			treeActor->GetProperty()->SetRepresentationToWireframe();
			treeActor->GetProperty()->SetOpacity(0.35);
		}
		else
			treeActor->GetProperty()->SetRepresentationToSurface();
		
		// add to the renderer
		renderer->AddActor(treeActor);
	}

	/* @brief Extracts all the points of depth = level from the octree */
	void extractPointsAtLevel(const int depth)
	{
		// clear the voxel center point cloud
		m_pVoxelCenterPointCloud->clear();
		
		// iterators
		//typename pcl::octree::OctreePointCloudVoxelCentroid<PointT>::Iterator octreeIter;
		//typename pcl::octree::OctreePointCloudVoxelCentroid<PointT>::Iterator octreeIterEnd = m_octree.end();
		//typename MyOctree::Iterator octreeIter(m_octree);
		MyOctree::LeafNodeIterator octreeIter(m_octree);
		//typename MyOctree::Iterator octreeIterEnd = m_octree.end();
		
		// for each voxel
		pcl::PointXYZ voxelCenterPoint;
		std::cout << "===== Extracting data at depth " << depth << "... " << std::flush;
		double start = pcl::getTime();
		//for(octreeIter = m_octree.begin(depth); octreeIter != octreeIterEnd; ++octreeIter)
		while(*++octreeIter)
		{
			// voxel
			Eigen::Vector3f voxel_min, voxel_max;
			m_octree.getVoxelBounds(octreeIter, voxel_min, voxel_max);
			
			// voxel center
			voxelCenterPoint.x = (voxel_min.x() + voxel_max.x()) / 2.0f;
			voxelCenterPoint.y = (voxel_min.y() + voxel_max.y()) / 2.0f;
			voxelCenterPoint.z = (voxel_min.z() + voxel_max.z()) / 2.0f;
			
			// add the voxel center
			m_pVoxelCenterPointCloud->push_back(voxelCenterPoint);
		}
		double end = pcl::getTime();
		printf("%zu points, %.4g seconds %.4g seconds/point =====\n", 
			    m_pVoxelCenterPointCloud->points.size(),
				 end - start,
				 (end - start) / static_cast<double>(m_pVoxelCenterPointCloud->points.size()));
		
		// update the scene
		update();
	}

	/* @brief Helper function to increase the octree display level by one */
	bool IncrementLevel()
	{
		if(displayedDepth < static_cast<int> (m_octree.getTreeDepth()))
		{
			displayedDepth++;
			extractPointsAtLevel(displayedDepth);
			return true;
		}
		return false;
	}
	
	/* @brief Helper function to decrease the octree display level by one */
	bool DecrementLevel()
	{
		if(displayedDepth > 0)
		{
			displayedDepth--;
			extractPointsAtLevel(displayedDepth);
			return true;
		}
		return false;
	}

protected:
	//visualizer
	pcl::visualization::PCLVisualizer viz;

	//original cloud
	typename pcl::PointCloud<PointT>::Ptr m_pOriginalPointCloud;

	//displayed_cloud
	pcl::PointCloud<pcl::PointXYZ>::Ptr m_pVoxelCenterPointCloud;

	//octree
	//typename pcl::octree::OctreePointCloudVoxelCentroid<PointT> m_octree;
	//typename MyOctree m_octree;
	Octree::Ptr m_pOctree;
	
	//level
	int displayedDepth;

	//bool to decide if we display points or cubes
	bool m_fDrawCubes, m_fDisplayPointsWithCubes, m_fWireframe;
};

}

#endif